<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1445562127256">{:repl-history {:ide [], :local [&quot;(shuffle '(1 2 3 4 5 6 7))&quot; &quot;(def suits [:spade :club :diamond :heart])&quot; &quot;(def ranks [2 3 4 5 6 7 8 9 10 :jack :queen :king :ace])&quot; &quot;(def cards\n  (for [suit suits\n        rank ranks]\n    [suit rank]))&quot; &quot;(clojure/pprint (cards))&quot; &quot;(clojure.pprint (cards))&quot; &quot;(clojure.pprint [])&quot; &quot;(println (cards))&quot; &quot;(def cards\n  (for [rank ranks\n        suit suits]\n    [rank suit]))&quot; &quot;(println (do cards))&quot; &quot;(println deck)&quot; &quot;(clojure.pprint deck)&quot; &quot;(defn deck []\n  (do (shuffle cards)))&quot; &quot;(def cards\n  (do (for [rank ranks\n             suit suits]\n         [rank suit])) )&quot; &quot;(clojure.pprint/pprint deck)&quot; &quot;(worth [2 :spades])&quot; &quot;(worth [2 :spade])&quot; &quot;(worth [2 :club])&quot; &quot;(doc take-nth)&quot; &quot;(clojure.pprint/pprint player2-hand)&quot; &quot;()&quot; &quot;(clojure.pprint/pprint player1-hand player2-hand)&quot; &quot;(clojure.pprint/pprint player1-hand)&quot; &quot;(play-game player1-delt-hand player2-delt-hand)\n&quot; &quot;\n(clojure.pprint cards)&quot; &quot;\n(clojure.pprint/pprint cards)&quot; &quot;(play-round [:ace :diamond] [:ace :heart])&quot; &quot;(frequencies (map &gt; '(1 2 3) '(4 2 3)))&quot; &quot;(frequencies (map &gt; '(1 2 3) '(1 1 1)))&quot; &quot;(-&gt;&gt; (frequencies (map &gt; '(1 2 3) '(1 1 1))))&quot; &quot;(-&gt;&gt; (frequencies (map &gt; '(1 2 3) '(1 1 1)))\n     (sort-by val &gt;)\n     (ffirst))&quot; &quot;(play-game [[2 :spade]] [[2 :spade]])&quot; &quot;(defn play-game [player1-cards player2-cards]\n    (let [score (-&gt;&gt; (map play-round player1-cards player2-cards)\n                     (frequencies))\n          winner (-&gt;&gt; score\n                      (sort-by val &gt;)\n                      (ffirst))]\n      (if (= (:p1 score)\n             (:p2 score))\n        :draw\n        winner)))&quot; &quot;(clojure.pprint/pprint cards)&quot; &quot;(play-game player1-hand player2-hand)&quot; &quot;(dorun (play-game player1-deck player2-deck))&quot; &quot;(defn play-game [p1-cards p2-cards]\n  (let [[p1-card &amp; p1-deck] p1-cards\n        [p2-card &amp; p2-deck] p2-cards\n        reward (shuffle [p1-card p2-card])]\n    (cond\n      (empty? p1-cards) \&quot;Player 2 Wins!\&quot;\n      (empty? p2-cards) \&quot;Player 1 Wins!\&quot;\n      ;reward player1\n      (= (play-round p1-card p2-card)\n         :player1-won)\n      (recur (concat p1-deck reward) p2-deck)\n      ;reward player2\n      :else\n      (recur p1-deck (concat p2-deck reward)))))&quot; &quot;(play-game player1-deck player2-deck)&quot; &quot;(deftest test-play-game\n  (testing \&quot;the player loses when they run out of cards\&quot;)\n   (is (= (play-game [] player2-deck) \&quot;Player 2 Wins Game!\&quot;)) )&quot;], :remote []}}</component>
</project>